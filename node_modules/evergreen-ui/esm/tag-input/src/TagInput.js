import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";

/**
 * @overview TagInput accepts multiple values that can be individually removed
 */
import React, { memo, forwardRef, useState } from 'react';
import PropTypes from 'prop-types';
import Box from 'ui-box';
import cx from 'classnames';
import { Text } from '../../typography';
import { useTheme } from '../../theme';
import { majorScale } from '../../scales';
import safeInvoke from '../../lib/safe-invoke';
import { useId } from '../../hooks';
import Tag from './Tag';
var GET_KEY_FOR_TAG_DELIMITER = {
  enter: 'Enter',
  space: ' '
};
var emptyProps = {};
var emptyArray = [];
var TagInput = memo(forwardRef(function TagInput(props, ref) {
  var _props$addOnBlur = props.addOnBlur,
      addOnBlur = _props$addOnBlur === void 0 ? false : _props$addOnBlur,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$height = props.height,
      height = _props$height === void 0 ? 32 : _props$height,
      _props$separator = props.separator,
      separator = _props$separator === void 0 ? /[,\n\r]/ : _props$separator,
      _props$values = props.values,
      values = _props$values === void 0 ? emptyArray : _props$values,
      _props$tagSubmitKey = props.tagSubmitKey,
      tagSubmitKey = _props$tagSubmitKey === void 0 ? 'enter' : _props$tagSubmitKey,
      _props$tagProps = props.tagProps,
      tagProps = _props$tagProps === void 0 ? emptyProps : _props$tagProps,
      onAdd = props.onAdd,
      onChange = props.onChange,
      onRemove = props.onRemove,
      onBlur = props.onBlur,
      onFocus = props.onFocus,
      onInputChange = props.onInputChange,
      className = props.className,
      _props$inputProps = props.inputProps,
      inputProps = _props$inputProps === void 0 ? {} : _props$inputProps,
      inputRef = props.inputRef,
      rest = _objectWithoutProperties(props, ["addOnBlur", "disabled", "height", "separator", "values", "tagSubmitKey", "tagProps", "onAdd", "onChange", "onRemove", "onBlur", "onFocus", "onInputChange", "className", "inputProps", "inputRef"]);

  var theme = useTheme();

  var _useState = useState(''),
      _useState2 = _slicedToArray(_useState, 2),
      inputValue = _useState2[0],
      setInputValue = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isFocused = _useState4[0],
      setIsFocused = _useState4[1];

  var id = useId('TagInput');

  var getValues = function getValues() {
    var inputValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return separator ? inputValue.split(separator).map(function (v) {
      return v.trim();
    }).filter(function (v) {
      return v.length > 0;
    }) : [inputValue];
  };

  var addTags = function addTags() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var newValues = getValues(value);
    var shouldClearInput = safeInvoke(onAdd, newValues);

    if (typeof onChange === 'function') {
      shouldClearInput = shouldClearInput || onChange(values.concat(newValues));
    }

    if (shouldClearInput !== false) {
      setInputValue('');
    }
  };

  var removeTagAtIndex = function removeTagAtIndex(index) {
    safeInvoke(onRemove, values[index], index); // Remove item at index as a new array

    var newValues = values.filter(function (_, i) {
      return i !== index;
    });
    safeInvoke(onChange, newValues);
  };

  var handleBackspaceToRemove = function handleBackspaceToRemove() {
    removeTagAtIndex(values.length - 1);
  };

  var handleBlur = function handleBlur(event) {
    var container = event.target;
    requestAnimationFrame(function () {
      if (!container.contains(document.activeElement)) {
        if (addOnBlur && inputValue) {
          addTags(inputValue);
        }

        setIsFocused(false);
      }
    });
    safeInvoke(onBlur, event);
  };

  var handleInputChange = function handleInputChange(event) {
    setInputValue(event.target.value);
    safeInvoke(onInputChange, event);
  };

  var handleInputFocus = function handleInputFocus(event) {
    setIsFocused(true);
    safeInvoke(onFocus, event);
  };

  var handleKeyDown = function handleKeyDown(event) {
    var _event$target = event.target,
        selectionEnd = _event$target.selectionEnd,
        value = _event$target.value;
    var key = GET_KEY_FOR_TAG_DELIMITER[tagSubmitKey];

    if (event.key === key) {
      event.preventDefault();
      addTags(value);
    } else if (event.key === 'Backspace' && selectionEnd === 0) {
      handleBackspaceToRemove(event);
    }
  };

  var handleRemoveTag = function handleRemoveTag(event) {
    // Using data attribute to simplify callback logic -- one handler for all children
    var index = Number(event.currentTarget.parentElement.getAttribute('data-tag-index'));
    removeTagAtIndex(index);
  };

  var maybeRenderTag = function maybeRenderTag(tag, index) {
    if (!tag) {
      return null;
    }

    var propsForElement = safeInvoke(tagProps, tag, index) || tagProps;
    return React.createElement(Tag, _extends({
      key: "".concat(tag, ":").concat(index),
      "data-tag-index": index,
      marginRight: majorScale(1),
      marginY: "6px",
      onRemove: disabled ? null : handleRemoveTag,
      isRemovable: !disabled
    }, propsForElement), tag);
  };

  var themedContainerClassName = theme.getTagInputClassName('default');
  var textSize = theme.getTextSizeForControlHeight(height);
  var borderRadius = theme.getBorderRadiusForControlHeight(height);
  var themedInputClassName = cx(theme.getTextInputClassName('none'), inputProps.className);
  return React.createElement(Box, _extends({
    "aria-disabled": disabled || undefined,
    "aria-activedescendant": isFocused ? id : undefined,
    borderRadius: borderRadius,
    className: cx(themedContainerClassName, className),
    paddingLeft: Math.round(height / 3.2),
    paddingRight: Math.round(height / 3.2),
    paddingY: "2px",
    ref: ref
  }, rest, {
    onBlur: handleBlur
  }), values.map(maybeRenderTag), React.createElement(Text, _extends({
    is: "input",
    id: id,
    color: disabled ? 'muted' : undefined,
    disabled: disabled,
    flexGrow: "1",
    height: height - 4,
    size: textSize,
    type: "text",
    value: inputValue
  }, inputProps, {
    className: themedInputClassName,
    ref: inputRef,
    onChange: handleInputChange,
    onFocus: handleInputFocus,
    onKeyDown: handleKeyDown
  })));
}));
TagInput.propTypes = {
  /** Whether or not the inputValue should be added to the tags when the input blurs. */
  addOnBlur: PropTypes.bool,

  /** The class name to apply to the container component. */
  className: PropTypes.string,

  /** Whether or not the input should be disabled. */
  disabled: PropTypes.bool,

  /** The vertical size of the input */
  height: PropTypes.number,

  /** Props to pass to the input component. Note that `ref` and `key` are not supported. See `inputRef`. */
  inputProps: PropTypes.object,

  /**
   * Ref handler for the input element.
   * (input: HTMLInputElement | null) => void
   */
  inputRef: PropTypes.func,

  /**
   * Callback invoked when new tags are added.
   * Returning `false` will prevent clearing the input.
   * (values: Array) => void | false
   */
  onAdd: PropTypes.func,

  /**
   * Callback invoked when focus on the input blurs.
   * (event) => void
   */
  onBlur: PropTypes.func,

  /**
   * Callback invoked when the tag values change.
   * Returning `false` will prevent clearing the input.
   * (values: Array) => void | false
   */
  onChange: PropTypes.func,

  /**
   * Callback invoked when the input receives focus.
   * (event) => void
   */
  onFocus: PropTypes.func,

  /**
   * Callback invoked when the value of the input is changed. Shorthand for `inputProps={{ onChange }}`.
   * (event) => void
   */
  onInputChange: PropTypes.func,

  /**
   * Callback invoked when a tag is removed.
   * Receives value and index of removed tag.
   * (value: string | node, index: number) => void
   */
  onRemove: PropTypes.func,

  /** Value or RegExp to split on pasted text or on enter keypress */
  separator: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp), PropTypes.oneOf([false])]),

  /** Provide props to tag component (actually `Badge`, for now). */
  tagProps: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),

  /** Key to press in order to submit a new tag while typing.  */
  tagSubmitKey: PropTypes.oneOf(['enter', 'space']),

  /** Controlled tag values. Each value is rendered inside a tag. */
  values: PropTypes.arrayOf(PropTypes.node)
};
export default TagInput;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWctaW5wdXQvc3JjL1RhZ0lucHV0LmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwibWVtbyIsImZvcndhcmRSZWYiLCJ1c2VTdGF0ZSIsIlByb3BUeXBlcyIsIkJveCIsImN4IiwiVGV4dCIsInVzZVRoZW1lIiwibWFqb3JTY2FsZSIsInNhZmVJbnZva2UiLCJ1c2VJZCIsIlRhZyIsIkdFVF9LRVlfRk9SX1RBR19ERUxJTUlURVIiLCJlbnRlciIsInNwYWNlIiwiZW1wdHlQcm9wcyIsImVtcHR5QXJyYXkiLCJUYWdJbnB1dCIsInByb3BzIiwicmVmIiwiYWRkT25CbHVyIiwiZGlzYWJsZWQiLCJoZWlnaHQiLCJzZXBhcmF0b3IiLCJ2YWx1ZXMiLCJ0YWdTdWJtaXRLZXkiLCJ0YWdQcm9wcyIsIm9uQWRkIiwib25DaGFuZ2UiLCJvblJlbW92ZSIsIm9uQmx1ciIsIm9uRm9jdXMiLCJvbklucHV0Q2hhbmdlIiwiY2xhc3NOYW1lIiwiaW5wdXRQcm9wcyIsImlucHV0UmVmIiwicmVzdCIsInRoZW1lIiwiaW5wdXRWYWx1ZSIsInNldElucHV0VmFsdWUiLCJpc0ZvY3VzZWQiLCJzZXRJc0ZvY3VzZWQiLCJpZCIsImdldFZhbHVlcyIsInNwbGl0IiwibWFwIiwidiIsInRyaW0iLCJmaWx0ZXIiLCJsZW5ndGgiLCJhZGRUYWdzIiwidmFsdWUiLCJuZXdWYWx1ZXMiLCJzaG91bGRDbGVhcklucHV0IiwiY29uY2F0IiwicmVtb3ZlVGFnQXRJbmRleCIsImluZGV4IiwiXyIsImkiLCJoYW5kbGVCYWNrc3BhY2VUb1JlbW92ZSIsImhhbmRsZUJsdXIiLCJldmVudCIsImNvbnRhaW5lciIsInRhcmdldCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNvbnRhaW5zIiwiZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiaGFuZGxlSW5wdXRDaGFuZ2UiLCJoYW5kbGVJbnB1dEZvY3VzIiwiaGFuZGxlS2V5RG93biIsInNlbGVjdGlvbkVuZCIsImtleSIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlUmVtb3ZlVGFnIiwiTnVtYmVyIiwiY3VycmVudFRhcmdldCIsInBhcmVudEVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJtYXliZVJlbmRlclRhZyIsInRhZyIsInByb3BzRm9yRWxlbWVudCIsInRoZW1lZENvbnRhaW5lckNsYXNzTmFtZSIsImdldFRhZ0lucHV0Q2xhc3NOYW1lIiwidGV4dFNpemUiLCJnZXRUZXh0U2l6ZUZvckNvbnRyb2xIZWlnaHQiLCJib3JkZXJSYWRpdXMiLCJnZXRCb3JkZXJSYWRpdXNGb3JDb250cm9sSGVpZ2h0IiwidGhlbWVkSW5wdXRDbGFzc05hbWUiLCJnZXRUZXh0SW5wdXRDbGFzc05hbWUiLCJ1bmRlZmluZWQiLCJNYXRoIiwicm91bmQiLCJwcm9wVHlwZXMiLCJib29sIiwic3RyaW5nIiwibnVtYmVyIiwib2JqZWN0IiwiZnVuYyIsIm9uZU9mVHlwZSIsImluc3RhbmNlT2YiLCJSZWdFeHAiLCJvbmVPZiIsImFycmF5T2YiLCJub2RlIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7OztBQUlBLE9BQU9BLEtBQVAsSUFBZ0JDLElBQWhCLEVBQXNCQyxVQUF0QixFQUFrQ0MsUUFBbEMsUUFBa0QsT0FBbEQ7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsT0FBT0MsR0FBUCxNQUFnQixRQUFoQjtBQUNBLE9BQU9DLEVBQVAsTUFBZSxZQUFmO0FBQ0EsU0FBU0MsSUFBVCxRQUFxQixrQkFBckI7QUFDQSxTQUFTQyxRQUFULFFBQXlCLGFBQXpCO0FBQ0EsU0FBU0MsVUFBVCxRQUEyQixjQUEzQjtBQUNBLE9BQU9DLFVBQVAsTUFBdUIsdUJBQXZCO0FBQ0EsU0FBU0MsS0FBVCxRQUFzQixhQUF0QjtBQUNBLE9BQU9DLEdBQVAsTUFBZ0IsT0FBaEI7QUFFQSxJQUFNQyx5QkFBeUIsR0FBRztBQUNoQ0MsRUFBQUEsS0FBSyxFQUFFLE9BRHlCO0FBRWhDQyxFQUFBQSxLQUFLLEVBQUU7QUFGeUIsQ0FBbEM7QUFLQSxJQUFNQyxVQUFVLEdBQUcsRUFBbkI7QUFDQSxJQUFNQyxVQUFVLEdBQUcsRUFBbkI7QUFFQSxJQUFNQyxRQUFRLEdBQUdqQixJQUFJLENBQ25CQyxVQUFVLENBQUMsU0FBU2dCLFFBQVQsQ0FBa0JDLEtBQWxCLEVBQXlCQyxHQUF6QixFQUE4QjtBQUFBLHlCQW1CbkNELEtBbkJtQyxDQUVyQ0UsU0FGcUM7QUFBQSxNQUVyQ0EsU0FGcUMsaUNBRXpCLEtBRnlCO0FBQUEsd0JBbUJuQ0YsS0FuQm1DLENBR3JDRyxRQUhxQztBQUFBLE1BR3JDQSxRQUhxQyxnQ0FHMUIsS0FIMEI7QUFBQSxzQkFtQm5DSCxLQW5CbUMsQ0FJckNJLE1BSnFDO0FBQUEsTUFJckNBLE1BSnFDLDhCQUk1QixFQUo0QjtBQUFBLHlCQW1CbkNKLEtBbkJtQyxDQUtyQ0ssU0FMcUM7QUFBQSxNQUtyQ0EsU0FMcUMsaUNBS3pCLFNBTHlCO0FBQUEsc0JBbUJuQ0wsS0FuQm1DLENBTXJDTSxNQU5xQztBQUFBLE1BTXJDQSxNQU5xQyw4QkFNNUJSLFVBTjRCO0FBQUEsNEJBbUJuQ0UsS0FuQm1DLENBT3JDTyxZQVBxQztBQUFBLE1BT3JDQSxZQVBxQyxvQ0FPdEIsT0FQc0I7QUFBQSx3QkFtQm5DUCxLQW5CbUMsQ0FRckNRLFFBUnFDO0FBQUEsTUFRckNBLFFBUnFDLGdDQVExQlgsVUFSMEI7QUFBQSxNQVNyQ1ksS0FUcUMsR0FtQm5DVCxLQW5CbUMsQ0FTckNTLEtBVHFDO0FBQUEsTUFVckNDLFFBVnFDLEdBbUJuQ1YsS0FuQm1DLENBVXJDVSxRQVZxQztBQUFBLE1BV3JDQyxRQVhxQyxHQW1CbkNYLEtBbkJtQyxDQVdyQ1csUUFYcUM7QUFBQSxNQVlyQ0MsTUFacUMsR0FtQm5DWixLQW5CbUMsQ0FZckNZLE1BWnFDO0FBQUEsTUFhckNDLE9BYnFDLEdBbUJuQ2IsS0FuQm1DLENBYXJDYSxPQWJxQztBQUFBLE1BY3JDQyxhQWRxQyxHQW1CbkNkLEtBbkJtQyxDQWNyQ2MsYUFkcUM7QUFBQSxNQWVyQ0MsU0FmcUMsR0FtQm5DZixLQW5CbUMsQ0FlckNlLFNBZnFDO0FBQUEsMEJBbUJuQ2YsS0FuQm1DLENBZ0JyQ2dCLFVBaEJxQztBQUFBLE1BZ0JyQ0EsVUFoQnFDLGtDQWdCeEIsRUFoQndCO0FBQUEsTUFpQnJDQyxRQWpCcUMsR0FtQm5DakIsS0FuQm1DLENBaUJyQ2lCLFFBakJxQztBQUFBLE1Ba0JsQ0MsSUFsQmtDLDRCQW1CbkNsQixLQW5CbUM7O0FBb0J2QyxNQUFNbUIsS0FBSyxHQUFHOUIsUUFBUSxFQUF0Qjs7QUFwQnVDLGtCQXNCSEwsUUFBUSxDQUFDLEVBQUQsQ0F0Qkw7QUFBQTtBQUFBLE1Bc0JoQ29DLFVBdEJnQztBQUFBLE1Bc0JwQkMsYUF0Qm9COztBQUFBLG1CQXVCTHJDLFFBQVEsQ0FBQyxLQUFELENBdkJIO0FBQUE7QUFBQSxNQXVCaENzQyxTQXZCZ0M7QUFBQSxNQXVCckJDLFlBdkJxQjs7QUF3QnZDLE1BQU1DLEVBQUUsR0FBR2hDLEtBQUssQ0FBQyxVQUFELENBQWhCOztBQUVBLE1BQU1pQyxTQUFTLEdBQUcsU0FBWkEsU0FBWTtBQUFBLFFBQUNMLFVBQUQsdUVBQWMsRUFBZDtBQUFBLFdBQ2hCZixTQUFTLEdBQ0xlLFVBQVUsQ0FDUE0sS0FESCxDQUNTckIsU0FEVCxFQUVHc0IsR0FGSCxDQUVPLFVBQUFDLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNDLElBQUYsRUFBSjtBQUFBLEtBRlIsRUFHR0MsTUFISCxDQUdVLFVBQUFGLENBQUM7QUFBQSxhQUFJQSxDQUFDLENBQUNHLE1BQUYsR0FBVyxDQUFmO0FBQUEsS0FIWCxDQURLLEdBS0wsQ0FBQ1gsVUFBRCxDQU5ZO0FBQUEsR0FBbEI7O0FBUUEsTUFBTVksT0FBTyxHQUFHLFNBQVZBLE9BQVUsR0FBZ0I7QUFBQSxRQUFmQyxLQUFlLHVFQUFQLEVBQU87QUFDOUIsUUFBTUMsU0FBUyxHQUFHVCxTQUFTLENBQUNRLEtBQUQsQ0FBM0I7QUFDQSxRQUFJRSxnQkFBZ0IsR0FBRzVDLFVBQVUsQ0FBQ2tCLEtBQUQsRUFBUXlCLFNBQVIsQ0FBakM7O0FBRUEsUUFBSSxPQUFPeEIsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ3lCLE1BQUFBLGdCQUFnQixHQUNkQSxnQkFBZ0IsSUFBSXpCLFFBQVEsQ0FBQ0osTUFBTSxDQUFDOEIsTUFBUCxDQUFjRixTQUFkLENBQUQsQ0FEOUI7QUFFRDs7QUFFRCxRQUFJQyxnQkFBZ0IsS0FBSyxLQUF6QixFQUFnQztBQUM5QmQsTUFBQUEsYUFBYSxDQUFDLEVBQUQsQ0FBYjtBQUNEO0FBQ0YsR0FaRDs7QUFjQSxNQUFNZ0IsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixDQUFBQyxLQUFLLEVBQUk7QUFDaEMvQyxJQUFBQSxVQUFVLENBQUNvQixRQUFELEVBQVdMLE1BQU0sQ0FBQ2dDLEtBQUQsQ0FBakIsRUFBMEJBLEtBQTFCLENBQVYsQ0FEZ0MsQ0FHaEM7O0FBQ0EsUUFBTUosU0FBUyxHQUFHNUIsTUFBTSxDQUFDd0IsTUFBUCxDQUFjLFVBQUNTLENBQUQsRUFBSUMsQ0FBSjtBQUFBLGFBQVVBLENBQUMsS0FBS0YsS0FBaEI7QUFBQSxLQUFkLENBQWxCO0FBQ0EvQyxJQUFBQSxVQUFVLENBQUNtQixRQUFELEVBQVd3QixTQUFYLENBQVY7QUFDRCxHQU5EOztBQVFBLE1BQU1PLHVCQUF1QixHQUFHLFNBQTFCQSx1QkFBMEIsR0FBTTtBQUNwQ0osSUFBQUEsZ0JBQWdCLENBQUMvQixNQUFNLENBQUN5QixNQUFQLEdBQWdCLENBQWpCLENBQWhCO0FBQ0QsR0FGRDs7QUFJQSxNQUFNVyxVQUFVLEdBQUcsU0FBYkEsVUFBYSxDQUFBQyxLQUFLLEVBQUk7QUFDMUIsUUFBTUMsU0FBUyxHQUFHRCxLQUFLLENBQUNFLE1BQXhCO0FBRUFDLElBQUFBLHFCQUFxQixDQUFDLFlBQU07QUFDMUIsVUFBSSxDQUFDRixTQUFTLENBQUNHLFFBQVYsQ0FBbUJDLFFBQVEsQ0FBQ0MsYUFBNUIsQ0FBTCxFQUFpRDtBQUMvQyxZQUFJL0MsU0FBUyxJQUFJa0IsVUFBakIsRUFBNkI7QUFDM0JZLFVBQUFBLE9BQU8sQ0FBQ1osVUFBRCxDQUFQO0FBQ0Q7O0FBRURHLFFBQUFBLFlBQVksQ0FBQyxLQUFELENBQVo7QUFDRDtBQUNGLEtBUm9CLENBQXJCO0FBVUFoQyxJQUFBQSxVQUFVLENBQUNxQixNQUFELEVBQVMrQixLQUFULENBQVY7QUFDRCxHQWREOztBQWdCQSxNQUFNTyxpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQW9CLENBQUFQLEtBQUssRUFBSTtBQUNqQ3RCLElBQUFBLGFBQWEsQ0FBQ3NCLEtBQUssQ0FBQ0UsTUFBTixDQUFhWixLQUFkLENBQWI7QUFDQTFDLElBQUFBLFVBQVUsQ0FBQ3VCLGFBQUQsRUFBZ0I2QixLQUFoQixDQUFWO0FBQ0QsR0FIRDs7QUFLQSxNQUFNUSxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLENBQUFSLEtBQUssRUFBSTtBQUNoQ3BCLElBQUFBLFlBQVksQ0FBQyxJQUFELENBQVo7QUFDQWhDLElBQUFBLFVBQVUsQ0FBQ3NCLE9BQUQsRUFBVThCLEtBQVYsQ0FBVjtBQUNELEdBSEQ7O0FBS0EsTUFBTVMsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFBVCxLQUFLLEVBQUk7QUFBQSx3QkFDR0EsS0FBSyxDQUFDRSxNQURUO0FBQUEsUUFDckJRLFlBRHFCLGlCQUNyQkEsWUFEcUI7QUFBQSxRQUNQcEIsS0FETyxpQkFDUEEsS0FETztBQUU3QixRQUFNcUIsR0FBRyxHQUFHNUQseUJBQXlCLENBQUNhLFlBQUQsQ0FBckM7O0FBRUEsUUFBSW9DLEtBQUssQ0FBQ1csR0FBTixLQUFjQSxHQUFsQixFQUF1QjtBQUNyQlgsTUFBQUEsS0FBSyxDQUFDWSxjQUFOO0FBQ0F2QixNQUFBQSxPQUFPLENBQUNDLEtBQUQsQ0FBUDtBQUNELEtBSEQsTUFHTyxJQUFJVSxLQUFLLENBQUNXLEdBQU4sS0FBYyxXQUFkLElBQTZCRCxZQUFZLEtBQUssQ0FBbEQsRUFBcUQ7QUFDMURaLE1BQUFBLHVCQUF1QixDQUFDRSxLQUFELENBQXZCO0FBQ0Q7QUFDRixHQVZEOztBQVlBLE1BQU1hLGVBQWUsR0FBRyxTQUFsQkEsZUFBa0IsQ0FBQWIsS0FBSyxFQUFJO0FBQy9CO0FBQ0EsUUFBTUwsS0FBSyxHQUFHbUIsTUFBTSxDQUNsQmQsS0FBSyxDQUFDZSxhQUFOLENBQW9CQyxhQUFwQixDQUFrQ0MsWUFBbEMsQ0FBK0MsZ0JBQS9DLENBRGtCLENBQXBCO0FBR0F2QixJQUFBQSxnQkFBZ0IsQ0FBQ0MsS0FBRCxDQUFoQjtBQUNELEdBTkQ7O0FBUUEsTUFBTXVCLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBQ0MsR0FBRCxFQUFNeEIsS0FBTixFQUFnQjtBQUNyQyxRQUFJLENBQUN3QixHQUFMLEVBQVU7QUFDUixhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFNQyxlQUFlLEdBQUd4RSxVQUFVLENBQUNpQixRQUFELEVBQVdzRCxHQUFYLEVBQWdCeEIsS0FBaEIsQ0FBVixJQUFvQzlCLFFBQTVEO0FBRUEsV0FDRSxvQkFBQyxHQUFEO0FBQ0UsTUFBQSxHQUFHLFlBQUtzRCxHQUFMLGNBQVl4QixLQUFaLENBREw7QUFFRSx3QkFBZ0JBLEtBRmxCO0FBR0UsTUFBQSxXQUFXLEVBQUVoRCxVQUFVLENBQUMsQ0FBRCxDQUh6QjtBQUlFLE1BQUEsT0FBTyxFQUFDLEtBSlY7QUFLRSxNQUFBLFFBQVEsRUFBRWEsUUFBUSxHQUFHLElBQUgsR0FBVXFELGVBTDlCO0FBTUUsTUFBQSxXQUFXLEVBQUUsQ0FBQ3JEO0FBTmhCLE9BT000RCxlQVBOLEdBU0dELEdBVEgsQ0FERjtBQWFELEdBcEJEOztBQXNCQSxNQUFNRSx3QkFBd0IsR0FBRzdDLEtBQUssQ0FBQzhDLG9CQUFOLENBQTJCLFNBQTNCLENBQWpDO0FBQ0EsTUFBTUMsUUFBUSxHQUFHL0MsS0FBSyxDQUFDZ0QsMkJBQU4sQ0FBa0MvRCxNQUFsQyxDQUFqQjtBQUNBLE1BQU1nRSxZQUFZLEdBQUdqRCxLQUFLLENBQUNrRCwrQkFBTixDQUFzQ2pFLE1BQXRDLENBQXJCO0FBQ0EsTUFBTWtFLG9CQUFvQixHQUFHbkYsRUFBRSxDQUFDZ0MsS0FBSyxDQUFDb0QscUJBQU4sQ0FBNEIsTUFBNUIsQ0FBRCxFQUFzQ3ZELFVBQVUsQ0FBQ0QsU0FBakQsQ0FBL0I7QUFFQSxTQUNFLG9CQUFDLEdBQUQ7QUFDRSxxQkFBZVosUUFBUSxJQUFJcUUsU0FEN0I7QUFFRSw2QkFBdUJsRCxTQUFTLEdBQUdFLEVBQUgsR0FBUWdELFNBRjFDO0FBR0UsSUFBQSxZQUFZLEVBQUVKLFlBSGhCO0FBSUUsSUFBQSxTQUFTLEVBQUVqRixFQUFFLENBQUM2RSx3QkFBRCxFQUEyQmpELFNBQTNCLENBSmY7QUFLRSxJQUFBLFdBQVcsRUFBRTBELElBQUksQ0FBQ0MsS0FBTCxDQUFXdEUsTUFBTSxHQUFHLEdBQXBCLENBTGY7QUFNRSxJQUFBLFlBQVksRUFBRXFFLElBQUksQ0FBQ0MsS0FBTCxDQUFXdEUsTUFBTSxHQUFHLEdBQXBCLENBTmhCO0FBT0UsSUFBQSxRQUFRLEVBQUMsS0FQWDtBQVFFLElBQUEsR0FBRyxFQUFFSDtBQVJQLEtBU01pQixJQVROO0FBVUUsSUFBQSxNQUFNLEVBQUV3QjtBQVZWLE1BWUdwQyxNQUFNLENBQUNxQixHQUFQLENBQVdrQyxjQUFYLENBWkgsRUFhRSxvQkFBQyxJQUFEO0FBQ0UsSUFBQSxFQUFFLEVBQUMsT0FETDtBQUVFLElBQUEsRUFBRSxFQUFFckMsRUFGTjtBQUdFLElBQUEsS0FBSyxFQUFFckIsUUFBUSxHQUFHLE9BQUgsR0FBYXFFLFNBSDlCO0FBSUUsSUFBQSxRQUFRLEVBQUVyRSxRQUpaO0FBS0UsSUFBQSxRQUFRLEVBQUMsR0FMWDtBQU1FLElBQUEsTUFBTSxFQUFFQyxNQUFNLEdBQUcsQ0FObkI7QUFPRSxJQUFBLElBQUksRUFBRThELFFBUFI7QUFRRSxJQUFBLElBQUksRUFBQyxNQVJQO0FBU0UsSUFBQSxLQUFLLEVBQUU5QztBQVRULEtBVU1KLFVBVk47QUFXRSxJQUFBLFNBQVMsRUFBRXNELG9CQVhiO0FBWUUsSUFBQSxHQUFHLEVBQUVyRCxRQVpQO0FBYUUsSUFBQSxRQUFRLEVBQUVpQyxpQkFiWjtBQWNFLElBQUEsT0FBTyxFQUFFQyxnQkFkWDtBQWVFLElBQUEsU0FBUyxFQUFFQztBQWZiLEtBYkYsQ0FERjtBQWlDRCxDQXRLUyxDQURTLENBQXJCO0FBMEtBckQsUUFBUSxDQUFDNEUsU0FBVCxHQUFxQjtBQUNuQjtBQUNBekUsRUFBQUEsU0FBUyxFQUFFakIsU0FBUyxDQUFDMkYsSUFGRjs7QUFHbkI7QUFDQTdELEVBQUFBLFNBQVMsRUFBRTlCLFNBQVMsQ0FBQzRGLE1BSkY7O0FBS25CO0FBQ0ExRSxFQUFBQSxRQUFRLEVBQUVsQixTQUFTLENBQUMyRixJQU5EOztBQU9uQjtBQUNBeEUsRUFBQUEsTUFBTSxFQUFFbkIsU0FBUyxDQUFDNkYsTUFSQzs7QUFTbkI7QUFDQTlELEVBQUFBLFVBQVUsRUFBRS9CLFNBQVMsQ0FBQzhGLE1BVkg7O0FBV25COzs7O0FBSUE5RCxFQUFBQSxRQUFRLEVBQUVoQyxTQUFTLENBQUMrRixJQWZEOztBQWdCbkI7Ozs7O0FBS0F2RSxFQUFBQSxLQUFLLEVBQUV4QixTQUFTLENBQUMrRixJQXJCRTs7QUFzQm5COzs7O0FBSUFwRSxFQUFBQSxNQUFNLEVBQUUzQixTQUFTLENBQUMrRixJQTFCQzs7QUEyQm5COzs7OztBQUtBdEUsRUFBQUEsUUFBUSxFQUFFekIsU0FBUyxDQUFDK0YsSUFoQ0Q7O0FBaUNuQjs7OztBQUlBbkUsRUFBQUEsT0FBTyxFQUFFNUIsU0FBUyxDQUFDK0YsSUFyQ0E7O0FBc0NuQjs7OztBQUlBbEUsRUFBQUEsYUFBYSxFQUFFN0IsU0FBUyxDQUFDK0YsSUExQ047O0FBMkNuQjs7Ozs7QUFLQXJFLEVBQUFBLFFBQVEsRUFBRTFCLFNBQVMsQ0FBQytGLElBaEREOztBQWlEbkI7QUFDQTNFLEVBQUFBLFNBQVMsRUFBRXBCLFNBQVMsQ0FBQ2dHLFNBQVYsQ0FBb0IsQ0FDN0JoRyxTQUFTLENBQUM0RixNQURtQixFQUU3QjVGLFNBQVMsQ0FBQ2lHLFVBQVYsQ0FBcUJDLE1BQXJCLENBRjZCLEVBRzdCbEcsU0FBUyxDQUFDbUcsS0FBVixDQUFnQixDQUFDLEtBQUQsQ0FBaEIsQ0FINkIsQ0FBcEIsQ0FsRFE7O0FBdURuQjtBQUNBNUUsRUFBQUEsUUFBUSxFQUFFdkIsU0FBUyxDQUFDZ0csU0FBVixDQUFvQixDQUFDaEcsU0FBUyxDQUFDOEYsTUFBWCxFQUFtQjlGLFNBQVMsQ0FBQytGLElBQTdCLENBQXBCLENBeERTOztBQXlEbkI7QUFDQXpFLEVBQUFBLFlBQVksRUFBRXRCLFNBQVMsQ0FBQ21HLEtBQVYsQ0FBZ0IsQ0FBQyxPQUFELEVBQVUsT0FBVixDQUFoQixDQTFESzs7QUEyRG5CO0FBQ0E5RSxFQUFBQSxNQUFNLEVBQUVyQixTQUFTLENBQUNvRyxPQUFWLENBQWtCcEcsU0FBUyxDQUFDcUcsSUFBNUI7QUE1RFcsQ0FBckI7QUErREEsZUFBZXZGLFFBQWYiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBvdmVydmlldyBUYWdJbnB1dCBhY2NlcHRzIG11bHRpcGxlIHZhbHVlcyB0aGF0IGNhbiBiZSBpbmRpdmlkdWFsbHkgcmVtb3ZlZFxuICovXG5cbmltcG9ydCBSZWFjdCwgeyBtZW1vLCBmb3J3YXJkUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IEJveCBmcm9tICd1aS1ib3gnXG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcydcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90eXBvZ3JhcGh5J1xuaW1wb3J0IHsgdXNlVGhlbWUgfSBmcm9tICcuLi8uLi90aGVtZSdcbmltcG9ydCB7IG1ham9yU2NhbGUgfSBmcm9tICcuLi8uLi9zY2FsZXMnXG5pbXBvcnQgc2FmZUludm9rZSBmcm9tICcuLi8uLi9saWIvc2FmZS1pbnZva2UnXG5pbXBvcnQgeyB1c2VJZCB9IGZyb20gJy4uLy4uL2hvb2tzJ1xuaW1wb3J0IFRhZyBmcm9tICcuL1RhZydcblxuY29uc3QgR0VUX0tFWV9GT1JfVEFHX0RFTElNSVRFUiA9IHtcbiAgZW50ZXI6ICdFbnRlcicsXG4gIHNwYWNlOiAnICdcbn1cblxuY29uc3QgZW1wdHlQcm9wcyA9IHt9XG5jb25zdCBlbXB0eUFycmF5ID0gW11cblxuY29uc3QgVGFnSW5wdXQgPSBtZW1vKFxuICBmb3J3YXJkUmVmKGZ1bmN0aW9uIFRhZ0lucHV0KHByb3BzLCByZWYpIHtcbiAgICBjb25zdCB7XG4gICAgICBhZGRPbkJsdXIgPSBmYWxzZSxcbiAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICBoZWlnaHQgPSAzMixcbiAgICAgIHNlcGFyYXRvciA9IC9bLFxcblxccl0vLFxuICAgICAgdmFsdWVzID0gZW1wdHlBcnJheSxcbiAgICAgIHRhZ1N1Ym1pdEtleSA9ICdlbnRlcicsXG4gICAgICB0YWdQcm9wcyA9IGVtcHR5UHJvcHMsXG4gICAgICBvbkFkZCxcbiAgICAgIG9uQ2hhbmdlLFxuICAgICAgb25SZW1vdmUsXG4gICAgICBvbkJsdXIsXG4gICAgICBvbkZvY3VzLFxuICAgICAgb25JbnB1dENoYW5nZSxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIGlucHV0UHJvcHMgPSB7fSxcbiAgICAgIGlucHV0UmVmLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBwcm9wc1xuICAgIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKVxuXG4gICAgY29uc3QgW2lucHV0VmFsdWUsIHNldElucHV0VmFsdWVdID0gdXNlU3RhdGUoJycpXG4gICAgY29uc3QgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IGlkID0gdXNlSWQoJ1RhZ0lucHV0JylcblxuICAgIGNvbnN0IGdldFZhbHVlcyA9IChpbnB1dFZhbHVlID0gJycpID0+XG4gICAgICBzZXBhcmF0b3JcbiAgICAgICAgPyBpbnB1dFZhbHVlXG4gICAgICAgICAgICAuc3BsaXQoc2VwYXJhdG9yKVxuICAgICAgICAgICAgLm1hcCh2ID0+IHYudHJpbSgpKVxuICAgICAgICAgICAgLmZpbHRlcih2ID0+IHYubGVuZ3RoID4gMClcbiAgICAgICAgOiBbaW5wdXRWYWx1ZV1cblxuICAgIGNvbnN0IGFkZFRhZ3MgPSAodmFsdWUgPSAnJykgPT4ge1xuICAgICAgY29uc3QgbmV3VmFsdWVzID0gZ2V0VmFsdWVzKHZhbHVlKVxuICAgICAgbGV0IHNob3VsZENsZWFySW5wdXQgPSBzYWZlSW52b2tlKG9uQWRkLCBuZXdWYWx1ZXMpXG5cbiAgICAgIGlmICh0eXBlb2Ygb25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2hvdWxkQ2xlYXJJbnB1dCA9XG4gICAgICAgICAgc2hvdWxkQ2xlYXJJbnB1dCB8fCBvbkNoYW5nZSh2YWx1ZXMuY29uY2F0KG5ld1ZhbHVlcykpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRDbGVhcklucHV0ICE9PSBmYWxzZSkge1xuICAgICAgICBzZXRJbnB1dFZhbHVlKCcnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlbW92ZVRhZ0F0SW5kZXggPSBpbmRleCA9PiB7XG4gICAgICBzYWZlSW52b2tlKG9uUmVtb3ZlLCB2YWx1ZXNbaW5kZXhdLCBpbmRleClcblxuICAgICAgLy8gUmVtb3ZlIGl0ZW0gYXQgaW5kZXggYXMgYSBuZXcgYXJyYXlcbiAgICAgIGNvbnN0IG5ld1ZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoKF8sIGkpID0+IGkgIT09IGluZGV4KVxuICAgICAgc2FmZUludm9rZShvbkNoYW5nZSwgbmV3VmFsdWVzKVxuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZUJhY2tzcGFjZVRvUmVtb3ZlID0gKCkgPT4ge1xuICAgICAgcmVtb3ZlVGFnQXRJbmRleCh2YWx1ZXMubGVuZ3RoIC0gMSlcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVCbHVyID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZXZlbnQudGFyZ2V0XG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIGlmICghY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgaWYgKGFkZE9uQmx1ciAmJiBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICBhZGRUYWdzKGlucHV0VmFsdWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2V0SXNGb2N1c2VkKGZhbHNlKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBzYWZlSW52b2tlKG9uQmx1ciwgZXZlbnQpXG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSBldmVudCA9PiB7XG4gICAgICBzZXRJbnB1dFZhbHVlKGV2ZW50LnRhcmdldC52YWx1ZSlcbiAgICAgIHNhZmVJbnZva2Uob25JbnB1dENoYW5nZSwgZXZlbnQpXG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlSW5wdXRGb2N1cyA9IGV2ZW50ID0+IHtcbiAgICAgIHNldElzRm9jdXNlZCh0cnVlKVxuICAgICAgc2FmZUludm9rZShvbkZvY3VzLCBldmVudClcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgeyBzZWxlY3Rpb25FbmQsIHZhbHVlIH0gPSBldmVudC50YXJnZXRcbiAgICAgIGNvbnN0IGtleSA9IEdFVF9LRVlfRk9SX1RBR19ERUxJTUlURVJbdGFnU3VibWl0S2V5XVxuXG4gICAgICBpZiAoZXZlbnQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICBhZGRUYWdzKHZhbHVlKVxuICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09ICdCYWNrc3BhY2UnICYmIHNlbGVjdGlvbkVuZCA9PT0gMCkge1xuICAgICAgICBoYW5kbGVCYWNrc3BhY2VUb1JlbW92ZShldmVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVSZW1vdmVUYWcgPSBldmVudCA9PiB7XG4gICAgICAvLyBVc2luZyBkYXRhIGF0dHJpYnV0ZSB0byBzaW1wbGlmeSBjYWxsYmFjayBsb2dpYyAtLSBvbmUgaGFuZGxlciBmb3IgYWxsIGNoaWxkcmVuXG4gICAgICBjb25zdCBpbmRleCA9IE51bWJlcihcbiAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldC5wYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YWctaW5kZXgnKVxuICAgICAgKVxuICAgICAgcmVtb3ZlVGFnQXRJbmRleChpbmRleClcbiAgICB9XG5cbiAgICBjb25zdCBtYXliZVJlbmRlclRhZyA9ICh0YWcsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIXRhZykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wc0ZvckVsZW1lbnQgPSBzYWZlSW52b2tlKHRhZ1Byb3BzLCB0YWcsIGluZGV4KSB8fCB0YWdQcm9wc1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICA8VGFnXG4gICAgICAgICAga2V5PXtgJHt0YWd9OiR7aW5kZXh9YH1cbiAgICAgICAgICBkYXRhLXRhZy1pbmRleD17aW5kZXh9XG4gICAgICAgICAgbWFyZ2luUmlnaHQ9e21ham9yU2NhbGUoMSl9XG4gICAgICAgICAgbWFyZ2luWT1cIjZweFwiXG4gICAgICAgICAgb25SZW1vdmU9e2Rpc2FibGVkID8gbnVsbCA6IGhhbmRsZVJlbW92ZVRhZ31cbiAgICAgICAgICBpc1JlbW92YWJsZT17IWRpc2FibGVkfVxuICAgICAgICAgIHsuLi5wcm9wc0ZvckVsZW1lbnR9XG4gICAgICAgID5cbiAgICAgICAgICB7dGFnfVxuICAgICAgICA8L1RhZz5cbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCB0aGVtZWRDb250YWluZXJDbGFzc05hbWUgPSB0aGVtZS5nZXRUYWdJbnB1dENsYXNzTmFtZSgnZGVmYXVsdCcpXG4gICAgY29uc3QgdGV4dFNpemUgPSB0aGVtZS5nZXRUZXh0U2l6ZUZvckNvbnRyb2xIZWlnaHQoaGVpZ2h0KVxuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRoZW1lLmdldEJvcmRlclJhZGl1c0ZvckNvbnRyb2xIZWlnaHQoaGVpZ2h0KVxuICAgIGNvbnN0IHRoZW1lZElucHV0Q2xhc3NOYW1lID0gY3godGhlbWUuZ2V0VGV4dElucHV0Q2xhc3NOYW1lKCdub25lJyksIGlucHV0UHJvcHMuY2xhc3NOYW1lKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgYXJpYS1kaXNhYmxlZD17ZGlzYWJsZWQgfHwgdW5kZWZpbmVkfVxuICAgICAgICBhcmlhLWFjdGl2ZWRlc2NlbmRhbnQ9e2lzRm9jdXNlZCA/IGlkIDogdW5kZWZpbmVkfVxuICAgICAgICBib3JkZXJSYWRpdXM9e2JvcmRlclJhZGl1c31cbiAgICAgICAgY2xhc3NOYW1lPXtjeCh0aGVtZWRDb250YWluZXJDbGFzc05hbWUsIGNsYXNzTmFtZSl9XG4gICAgICAgIHBhZGRpbmdMZWZ0PXtNYXRoLnJvdW5kKGhlaWdodCAvIDMuMil9XG4gICAgICAgIHBhZGRpbmdSaWdodD17TWF0aC5yb3VuZChoZWlnaHQgLyAzLjIpfVxuICAgICAgICBwYWRkaW5nWT1cIjJweFwiXG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgb25CbHVyPXtoYW5kbGVCbHVyfVxuICAgICAgPlxuICAgICAgICB7dmFsdWVzLm1hcChtYXliZVJlbmRlclRhZyl9XG4gICAgICAgIDxUZXh0XG4gICAgICAgICAgaXM9XCJpbnB1dFwiXG4gICAgICAgICAgaWQ9e2lkfVxuICAgICAgICAgIGNvbG9yPXtkaXNhYmxlZCA/ICdtdXRlZCcgOiB1bmRlZmluZWR9XG4gICAgICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgICAgIGZsZXhHcm93PVwiMVwiXG4gICAgICAgICAgaGVpZ2h0PXtoZWlnaHQgLSA0fVxuICAgICAgICAgIHNpemU9e3RleHRTaXplfVxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICB2YWx1ZT17aW5wdXRWYWx1ZX1cbiAgICAgICAgICB7Li4uaW5wdXRQcm9wc31cbiAgICAgICAgICBjbGFzc05hbWU9e3RoZW1lZElucHV0Q2xhc3NOYW1lfVxuICAgICAgICAgIHJlZj17aW5wdXRSZWZ9XG4gICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfVxuICAgICAgICAgIG9uRm9jdXM9e2hhbmRsZUlucHV0Rm9jdXN9XG4gICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxuICAgICAgICAvPlxuICAgICAgPC9Cb3g+XG4gICAgKVxuICB9KVxuKVxuXG5UYWdJbnB1dC5wcm9wVHlwZXMgPSB7XG4gIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGUgaW5wdXRWYWx1ZSBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHRhZ3Mgd2hlbiB0aGUgaW5wdXQgYmx1cnMuICovXG4gIGFkZE9uQmx1cjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKiBUaGUgY2xhc3MgbmFtZSB0byBhcHBseSB0byB0aGUgY29udGFpbmVyIGNvbXBvbmVudC4gKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAvKiogV2hldGhlciBvciBub3QgdGhlIGlucHV0IHNob3VsZCBiZSBkaXNhYmxlZC4gKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAvKiogVGhlIHZlcnRpY2FsIHNpemUgb2YgdGhlIGlucHV0ICovXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqIFByb3BzIHRvIHBhc3MgdG8gdGhlIGlucHV0IGNvbXBvbmVudC4gTm90ZSB0aGF0IGByZWZgIGFuZCBga2V5YCBhcmUgbm90IHN1cHBvcnRlZC4gU2VlIGBpbnB1dFJlZmAuICovXG4gIGlucHV0UHJvcHM6IFByb3BUeXBlcy5vYmplY3QsXG4gIC8qKlxuICAgKiBSZWYgaGFuZGxlciBmb3IgdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIChpbnB1dDogSFRNTElucHV0RWxlbWVudCB8IG51bGwpID0+IHZvaWRcbiAgICovXG4gIGlucHV0UmVmOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGludm9rZWQgd2hlbiBuZXcgdGFncyBhcmUgYWRkZWQuXG4gICAqIFJldHVybmluZyBgZmFsc2VgIHdpbGwgcHJldmVudCBjbGVhcmluZyB0aGUgaW5wdXQuXG4gICAqICh2YWx1ZXM6IEFycmF5KSA9PiB2b2lkIHwgZmFsc2VcbiAgICovXG4gIG9uQWRkOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGludm9rZWQgd2hlbiBmb2N1cyBvbiB0aGUgaW5wdXQgYmx1cnMuXG4gICAqIChldmVudCkgPT4gdm9pZFxuICAgKi9cbiAgb25CbHVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgdGFnIHZhbHVlcyBjaGFuZ2UuXG4gICAqIFJldHVybmluZyBgZmFsc2VgIHdpbGwgcHJldmVudCBjbGVhcmluZyB0aGUgaW5wdXQuXG4gICAqICh2YWx1ZXM6IEFycmF5KSA9PiB2b2lkIHwgZmFsc2VcbiAgICovXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXMuXG4gICAqIChldmVudCkgPT4gdm9pZFxuICAgKi9cbiAgb25Gb2N1czogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBDYWxsYmFjayBpbnZva2VkIHdoZW4gdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBpcyBjaGFuZ2VkLiBTaG9ydGhhbmQgZm9yIGBpbnB1dFByb3BzPXt7IG9uQ2hhbmdlIH19YC5cbiAgICogKGV2ZW50KSA9PiB2b2lkXG4gICAqL1xuICBvbklucHV0Q2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGludm9rZWQgd2hlbiBhIHRhZyBpcyByZW1vdmVkLlxuICAgKiBSZWNlaXZlcyB2YWx1ZSBhbmQgaW5kZXggb2YgcmVtb3ZlZCB0YWcuXG4gICAqICh2YWx1ZTogc3RyaW5nIHwgbm9kZSwgaW5kZXg6IG51bWJlcikgPT4gdm9pZFxuICAgKi9cbiAgb25SZW1vdmU6IFByb3BUeXBlcy5mdW5jLFxuICAvKiogVmFsdWUgb3IgUmVnRXhwIHRvIHNwbGl0IG9uIHBhc3RlZCB0ZXh0IG9yIG9uIGVudGVyIGtleXByZXNzICovXG4gIHNlcGFyYXRvcjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLnN0cmluZyxcbiAgICBQcm9wVHlwZXMuaW5zdGFuY2VPZihSZWdFeHApLFxuICAgIFByb3BUeXBlcy5vbmVPZihbZmFsc2VdKVxuICBdKSxcbiAgLyoqIFByb3ZpZGUgcHJvcHMgdG8gdGFnIGNvbXBvbmVudCAoYWN0dWFsbHkgYEJhZGdlYCwgZm9yIG5vdykuICovXG4gIHRhZ1Byb3BzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuZnVuY10pLFxuICAvKiogS2V5IHRvIHByZXNzIGluIG9yZGVyIHRvIHN1Ym1pdCBhIG5ldyB0YWcgd2hpbGUgdHlwaW5nLiAgKi9cbiAgdGFnU3VibWl0S2V5OiBQcm9wVHlwZXMub25lT2YoWydlbnRlcicsICdzcGFjZSddKSxcbiAgLyoqIENvbnRyb2xsZWQgdGFnIHZhbHVlcy4gRWFjaCB2YWx1ZSBpcyByZW5kZXJlZCBpbnNpZGUgYSB0YWcuICovXG4gIHZhbHVlczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRhZ0lucHV0XG4iXX0=