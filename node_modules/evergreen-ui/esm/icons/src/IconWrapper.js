import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { forwardRef, memo } from 'react';
import PropTypes from 'prop-types';
import ReactIs from 'react-is';
import Box from 'ui-box';
/**
 * This is an internal helper component for rendering custom or Evergreen icons
 * Box props are applied to the outer Box container, and Evergreen icon-specific props are added to the icon element.
 */

export var IconWrapper = memo(forwardRef(function Icon(_ref, ref) {
  var icon = _ref.icon,
      color = _ref.color,
      size = _ref.size,
      title = _ref.title,
      props = _objectWithoutProperties(_ref, ["icon", "color", "size", "title"]);

  if (!icon || typeof icon === 'string') {
    return null;
  }

  var iconProps = {
    color: color,
    size: size,
    title: title
  };
  var iconWithProps = null;

  if (ReactIs.isValidElementType(icon)) {
    var Component = icon;
    iconWithProps = React.createElement(Component, _extends({
      ref: ref
    }, iconProps));
  } else if (React.isValidElement(icon)) {
    iconWithProps = React.cloneElement(icon, _objectSpread(_objectSpread(_objectSpread({}, iconProps), icon.props), {}, {
      ref: ref
    }));
  }

  return React.createElement(Box, _extends({
    display: "inline-flex"
  }, props), iconWithProps);
}));
IconWrapper.propTypes = {
  /**
   * Color of icon. Equivalent to setting CSS `fill` property.
   */
  color: PropTypes.string,

  /**
   * The icon component - whether an Evergreen icon or a custom icon node:
   *
   * - If `null` or `undefined` or `false`, this component will render nothing.
   * - If given a `JSX.Element`, that element will be rendered, with size/color/title props cloned into it
   * - If given a React element type, it will be rendered with the other icon props
   *   As a consumer, you should never use `<IconWrapper icon={<element />}` directly; simply render `<element />` instead.
   */
  icon: PropTypes.oneOfType([PropTypes.elementType, PropTypes.element]),

  /**
   * Size of the icon, in pixels.
   * Icons contains 16px and 20px SVG icon paths,
   * and chooses the appropriate resolution based on this prop.
   */
  size: PropTypes.number,

  /**
   * Description string.
   * Browsers usually render this as a tooltip on hover, whereas screen
   * readers will use it for aural feedback.
   * By default, this is set to the icon's name for accessibility.
   */
  title: PropTypes.string
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9pY29ucy9zcmMvSWNvbldyYXBwZXIuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJmb3J3YXJkUmVmIiwibWVtbyIsIlByb3BUeXBlcyIsIlJlYWN0SXMiLCJCb3giLCJJY29uV3JhcHBlciIsIkljb24iLCJyZWYiLCJpY29uIiwiY29sb3IiLCJzaXplIiwidGl0bGUiLCJwcm9wcyIsImljb25Qcm9wcyIsImljb25XaXRoUHJvcHMiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJDb21wb25lbnQiLCJpc1ZhbGlkRWxlbWVudCIsImNsb25lRWxlbWVudCIsInByb3BUeXBlcyIsInN0cmluZyIsIm9uZU9mVHlwZSIsImVsZW1lbnRUeXBlIiwiZWxlbWVudCIsIm51bWJlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxVQUFoQixFQUE0QkMsSUFBNUIsUUFBd0MsT0FBeEM7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsT0FBT0MsT0FBUCxNQUFvQixVQUFwQjtBQUNBLE9BQU9DLEdBQVAsTUFBZ0IsUUFBaEI7QUFFQTs7Ozs7QUFJQSxPQUFPLElBQU1DLFdBQVcsR0FBR0osSUFBSSxDQUM3QkQsVUFBVSxDQUFDLFNBQVNNLElBQVQsT0FFVEMsR0FGUyxFQUdUO0FBQUEsTUFGRUMsSUFFRixRQUZFQSxJQUVGO0FBQUEsTUFGUUMsS0FFUixRQUZRQSxLQUVSO0FBQUEsTUFGZUMsSUFFZixRQUZlQSxJQUVmO0FBQUEsTUFGcUJDLEtBRXJCLFFBRnFCQSxLQUVyQjtBQUFBLE1BRitCQyxLQUUvQjs7QUFDQSxNQUFJLENBQUNKLElBQUQsSUFBUyxPQUFPQSxJQUFQLEtBQWdCLFFBQTdCLEVBQXVDO0FBQ3JDLFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQU1LLFNBQVMsR0FBRztBQUNoQkosSUFBQUEsS0FBSyxFQUFMQSxLQURnQjtBQUVoQkMsSUFBQUEsSUFBSSxFQUFKQSxJQUZnQjtBQUdoQkMsSUFBQUEsS0FBSyxFQUFMQTtBQUhnQixHQUFsQjtBQU1BLE1BQUlHLGFBQWEsR0FBRyxJQUFwQjs7QUFDQSxNQUFJWCxPQUFPLENBQUNZLGtCQUFSLENBQTJCUCxJQUEzQixDQUFKLEVBQXNDO0FBQ3BDLFFBQU1RLFNBQVMsR0FBR1IsSUFBbEI7QUFDQU0sSUFBQUEsYUFBYSxHQUFHLG9CQUFDLFNBQUQ7QUFBVyxNQUFBLEdBQUcsRUFBRVA7QUFBaEIsT0FBeUJNLFNBQXpCLEVBQWhCO0FBQ0QsR0FIRCxNQUdPLElBQUlkLEtBQUssQ0FBQ2tCLGNBQU4sQ0FBcUJULElBQXJCLENBQUosRUFBZ0M7QUFDckNNLElBQUFBLGFBQWEsR0FBR2YsS0FBSyxDQUFDbUIsWUFBTixDQUFtQlYsSUFBbkIsZ0RBQThCSyxTQUE5QixHQUE0Q0wsSUFBSSxDQUFDSSxLQUFqRDtBQUF3REwsTUFBQUEsR0FBRyxFQUFIQTtBQUF4RCxPQUFoQjtBQUNEOztBQUVELFNBQ0Usb0JBQUMsR0FBRDtBQUFLLElBQUEsT0FBTyxFQUFDO0FBQWIsS0FBK0JLLEtBQS9CLEdBQ0dFLGFBREgsQ0FERjtBQUtELENBM0JTLENBRG1CLENBQXhCO0FBK0JQVCxXQUFXLENBQUNjLFNBQVosR0FBd0I7QUFDdEI7OztBQUdBVixFQUFBQSxLQUFLLEVBQUVQLFNBQVMsQ0FBQ2tCLE1BSks7O0FBTXRCOzs7Ozs7OztBQVFBWixFQUFBQSxJQUFJLEVBQUVOLFNBQVMsQ0FBQ21CLFNBQVYsQ0FBb0IsQ0FBQ25CLFNBQVMsQ0FBQ29CLFdBQVgsRUFBd0JwQixTQUFTLENBQUNxQixPQUFsQyxDQUFwQixDQWRnQjs7QUFnQnRCOzs7OztBQUtBYixFQUFBQSxJQUFJLEVBQUVSLFNBQVMsQ0FBQ3NCLE1BckJNOztBQXVCdEI7Ozs7OztBQU1BYixFQUFBQSxLQUFLLEVBQUVULFNBQVMsQ0FBQ2tCO0FBN0JLLENBQXhCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYsIG1lbW8gfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBSZWFjdElzIGZyb20gJ3JlYWN0LWlzJ1xuaW1wb3J0IEJveCBmcm9tICd1aS1ib3gnXG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbnRlcm5hbCBoZWxwZXIgY29tcG9uZW50IGZvciByZW5kZXJpbmcgY3VzdG9tIG9yIEV2ZXJncmVlbiBpY29uc1xuICogQm94IHByb3BzIGFyZSBhcHBsaWVkIHRvIHRoZSBvdXRlciBCb3ggY29udGFpbmVyLCBhbmQgRXZlcmdyZWVuIGljb24tc3BlY2lmaWMgcHJvcHMgYXJlIGFkZGVkIHRvIHRoZSBpY29uIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBJY29uV3JhcHBlciA9IG1lbW8oXG4gIGZvcndhcmRSZWYoZnVuY3Rpb24gSWNvbihcbiAgICB7IGljb24sIGNvbG9yLCBzaXplLCB0aXRsZSwgLi4ucHJvcHMgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgaWYgKCFpY29uIHx8IHR5cGVvZiBpY29uID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBpY29uUHJvcHMgPSB7XG4gICAgICBjb2xvcixcbiAgICAgIHNpemUsXG4gICAgICB0aXRsZSxcbiAgICB9XG5cbiAgICBsZXQgaWNvbldpdGhQcm9wcyA9IG51bGxcbiAgICBpZiAoUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUoaWNvbikpIHtcbiAgICAgIGNvbnN0IENvbXBvbmVudCA9IGljb25cbiAgICAgIGljb25XaXRoUHJvcHMgPSA8Q29tcG9uZW50IHJlZj17cmVmfSB7Li4uaWNvblByb3BzfSAvPlxuICAgIH0gZWxzZSBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQoaWNvbikpIHtcbiAgICAgIGljb25XaXRoUHJvcHMgPSBSZWFjdC5jbG9uZUVsZW1lbnQoaWNvbiwgeyAuLi5pY29uUHJvcHMsIC4uLmljb24ucHJvcHMsIHJlZiB9KVxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94IGRpc3BsYXk9XCJpbmxpbmUtZmxleFwiIHsuLi5wcm9wc30+XG4gICAgICAgIHtpY29uV2l0aFByb3BzfVxuICAgICAgPC9Cb3g+XG4gICAgKVxuICB9KVxuKVxuXG5JY29uV3JhcHBlci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBDb2xvciBvZiBpY29uLiBFcXVpdmFsZW50IHRvIHNldHRpbmcgQ1NTIGBmaWxsYCBwcm9wZXJ0eS5cbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgaWNvbiBjb21wb25lbnQgLSB3aGV0aGVyIGFuIEV2ZXJncmVlbiBpY29uIG9yIGEgY3VzdG9tIGljb24gbm9kZTpcbiAgICpcbiAgICogLSBJZiBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgb3IgYGZhbHNlYCwgdGhpcyBjb21wb25lbnQgd2lsbCByZW5kZXIgbm90aGluZy5cbiAgICogLSBJZiBnaXZlbiBhIGBKU1guRWxlbWVudGAsIHRoYXQgZWxlbWVudCB3aWxsIGJlIHJlbmRlcmVkLCB3aXRoIHNpemUvY29sb3IvdGl0bGUgcHJvcHMgY2xvbmVkIGludG8gaXRcbiAgICogLSBJZiBnaXZlbiBhIFJlYWN0IGVsZW1lbnQgdHlwZSwgaXQgd2lsbCBiZSByZW5kZXJlZCB3aXRoIHRoZSBvdGhlciBpY29uIHByb3BzXG4gICAqICAgQXMgYSBjb25zdW1lciwgeW91IHNob3VsZCBuZXZlciB1c2UgYDxJY29uV3JhcHBlciBpY29uPXs8ZWxlbWVudCAvPn1gIGRpcmVjdGx5OyBzaW1wbHkgcmVuZGVyIGA8ZWxlbWVudCAvPmAgaW5zdGVhZC5cbiAgICovXG4gIGljb246IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5lbGVtZW50VHlwZSwgUHJvcFR5cGVzLmVsZW1lbnRdKSxcblxuICAvKipcbiAgICogU2l6ZSBvZiB0aGUgaWNvbiwgaW4gcGl4ZWxzLlxuICAgKiBJY29ucyBjb250YWlucyAxNnB4IGFuZCAyMHB4IFNWRyBpY29uIHBhdGhzLFxuICAgKiBhbmQgY2hvb3NlcyB0aGUgYXBwcm9wcmlhdGUgcmVzb2x1dGlvbiBiYXNlZCBvbiB0aGlzIHByb3AuXG4gICAqL1xuICBzaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBEZXNjcmlwdGlvbiBzdHJpbmcuXG4gICAqIEJyb3dzZXJzIHVzdWFsbHkgcmVuZGVyIHRoaXMgYXMgYSB0b29sdGlwIG9uIGhvdmVyLCB3aGVyZWFzIHNjcmVlblxuICAgKiByZWFkZXJzIHdpbGwgdXNlIGl0IGZvciBhdXJhbCBmZWVkYmFjay5cbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpcyBzZXQgdG8gdGhlIGljb24ncyBuYW1lIGZvciBhY2Nlc3NpYmlsaXR5LlxuICAgKi9cbiAgdGl0bGU6IFByb3BUeXBlcy5zdHJpbmdcbn1cbiJdfQ==